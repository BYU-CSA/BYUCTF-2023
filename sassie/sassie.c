#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/mman.h>
#include "md5.h"

#define MAP_ANONYMOUS 0x20

__attribute__((constructor)) void flush_buf() {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
}

// runs alarm(5) before main
void setup() {
    alarm(5);
    return;
}

// XORs buf with key to dynamically create a string
void create_string(char *buf, int len, char *key) {
    for (int i = 0; i < len; i++) {
        buf[i] = buf[i] ^ key[i % strlen(key)];
    }
    return;
}

// check for gdb process
void check_for_gdb(int procid) {

    // make /proc/%d/cmdline
    char cmdline[18] = {0xb0, 0x1e, 0xed, 0x01, 0xfc, 0x41, 0xba, 0x0a, 0xb0, 0x0d, 0xf2, 0x0a, 0xf3, 0x07, 0xf1, 0x0b, 0x00};
    char key2[3] = {0x9f, 0x6e, 0x00};
    create_string(cmdline, 16, key2);

    // get cmdline of proc
    char path[24];
    sprintf(path, cmdline, procid);

    char r[2] = {0x9b, 0x00};
    char key3[2] = {0xe9, 0x00};
    create_string(r, 1, key3);
    FILE *f = fopen(path, r);
    if (f == NULL) { return; }

    char buf[100];
    fgets(buf, 99, f);
    fclose(f);

    // check for gdb
    int one = 0xe5;
    int two = 0x1e;
    int three = 0x51;

    if (buf[1] == (two^0x7a) && buf[2] == (three^0x33) && buf[0] == (one^0x82)) {
        exit(1);
    }

    return;
}

// makes a list of process IDs and calls check_for_gdb on them
void get_proc_ids(DIR* d) {
    struct dirent *dir;

    // check for gdb
    while ((dir = readdir(d)) != NULL) {
        int procid = atoi(dir->d_name);
        if (procid != 0) {
            check_for_gdb(procid);
        }
    }
}

// ensure MD5 hash of contents is 9cdfb439c7876e703e307864c9167a15 (lol)
void check_md5_hash(char *buf) {
    // make MD5 string
    char md5[18] = {0x1d, 0xe9, 0x89, 0x72, 0x19, 0x06, 0x58, 0x4d, 0x75, 0xee, 0xf9, 0x52, 0xf4, 0x5d, 0xa4, 0x15, 0x00};
    char key4[6] = {0x81, 0x36, 0x3d, 0x4b, 0xde, 0x00};
    create_string(md5, 15, key4);

    // get actual MD5
    uint8_t result[16];
    md5String(buf, result);

    // compare
    for (int i = 0; i < 16; i++) {
        if ((char) result[i] != md5[i]) {
            printf("Wrong!\n");
            exit(1);
        }
    }
}

int main() {
    // exit after 5 seconds
    setup();

    // generate strings
    char proc_base[6] = {0xe8, 0x7d, 0x61, 0xa8, 0x6e, 0x00}; // /proc
    char key1[4] = {0xc7, 0x0d, 0x13, 0x00};
    create_string(proc_base, 5, key1);

    // make a list of process IDs, then check for gdb in them
    DIR *d;
    d = opendir(proc_base);
    if (d) {
        get_proc_ids(d);
        closedir(d);
    }

    // generate string "/tmp/tmpt2nxegs1"
    char tmpfile[18] = {0x85, 0x6d, 0x38, 0x59, 0x07, 0xad, 0xb6, 0xda, 0x6d, 0x67, 0x47, 0x50, 0xbc, 0xbc, 0xd9, 0x28, 0x00};
    char key5[8] = {0xaa, 0x19, 0x55, 0x29, 0x28, 0xd9, 0xdb, 0x00};
    create_string(tmpfile, 16, key5);

    // check for /tmp/tmpt2nxegs1
    FILE *f = fopen(tmpfile, "r");
    if (f == NULL) { return 0; }

    // check contents
    char buf[100];
    fgets(buf, 99, f);
    fclose(f);
    check_md5_hash(buf);

    // create shellcode in 0x54551300000
    mmap((char *)0x54551300000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED|MAP_ANONYMOUS, -1, 0);

    // write to shellcode
    char shellcode_buf[0x2000] = {
        // sets 0x54551300300 to pre-XORed flag = {0x24, 0x41, 0x64, 0xb8, 0xa5, 0xc5, 0x3d, 0x4b, 0x7e, 0xa9, 0xa3, 0xda, 0x19, 0x5e, 0x21, 0xa9, 0x8e, 0xc1, 0x75, 0x09, 0x7f, 0xbc, 0x8e, 0x96, 0x72, 0x0d, 0x24, 0xea, 0xe2, 0xde}

        0x48, 0xb8, 0x00, 0x03, 0x30, 0x51, 0x45, 0x05, 0x00, 0x00, // movabs rax, 0x54551300300
        0x48, 0x89, 0x45, 0xf8,                                     // mov [rbp-0x8], rax
        0x48, 0xb8, 0x24, 0x41, 0x64, 0xb8, 0xa5, 0xc5, 0x3d, 0x4b, // movabs rax, 0x4b3dc5a5b8644124
        0x48, 0xba, 0x7e, 0xa9, 0xa3, 0xda, 0x19, 0x5e, 0x21, 0xa9, // movabs rdx, 0xa9215e19daa3a97e
        0x48, 0x89, 0x45, 0xd0,                                     // mov [rbp-0x30], rax
        0x48, 0x89, 0x55, 0xd8,                                     // mov [rbp-0x28], rdx
        0x48, 0xb8, 0x21, 0xa9, 0x8e, 0xc1, 0x75, 0x09, 0x7f, 0xbc, // movabs rax, 0xbc7f0975c18ea921
        0x48, 0xba, 0x8e, 0x96, 0x72, 0x0d, 0x24, 0xea, 0xe2, 0xde, // movabs rdx, 0xdee2ea240d72968e
        0x48, 0x89, 0x45, 0xde,                                     // mov [rbp-0x22], rax
        0x48, 0x89, 0x55, 0xe6,                                     // mov [rbp-0x1a], rdx
        0x48, 0x8b, 0x4d, 0xf8,                                     // mov rcx, [rbp-0x8]
        0x48, 0x8b, 0x45, 0xd0,                                     // mov rax, [rbp-0x30]
        0x48, 0x8b, 0x55, 0xd8,                                     // mov rdx, [rbp-0x28]
        0x48, 0x89, 0x01,                                           // mov [rcx], rax
        0x48, 0x89, 0x51, 0x08,                                     // mov [rcx+0x8], rdx
        0x48, 0x8b, 0x45, 0xde,                                     // mov rax, [rbp-0x22]
        0x48, 0x8b, 0x55, 0xe6,                                     // mov rdx, [rbp-0x1a]
        0x48, 0x89, 0x41, 0x0e,                                     // mov [rcx+0xe], rax
        0x48, 0x89, 0x51, 0x16,                                     // mov [rcx+0x16], rdx

        /*
        This next section is shellcode that copies and runs the below shellcode

        // XORs flag with {0x46, 0x38, 0x11, 0xdb, 0xd1, 0xa3}
        0x48, 0xb8, 0x00, 0x03, 0x30, 0x51, 0x45, 0x05, 0x00, 0x00, // movabs rax, 0x54551300300
        0x48, 0x89, 0x45, 0xf0,                                     // mov [rbp-0x10], rax
        0xc7, 0x45, 0xea, 0x46, 0x38, 0x11, 0xdb,                   // mov [rbp-0x16], 0xdb113846
        0x66, 0xc7, 0x45, 0xee, 0xd1, 0xa3,                         // mov [rbp-0x12], 0xa3d1
        0xc7, 0x45, 0xfc, 0x00, 0x00, 0x00, 0x00,                   // mov [rbp-0x4], 0x0
        0xeb, 0x56,                                                 // jmp 0x56
        0x8b, 0x45, 0xfc,                                           // mov eax, [rbp-0x4]
        0x48, 0x63, 0xd0,                                           // movsxd rdx, eax
        0x48, 0x8b, 0x45, 0xf0,                                     // mov rax, [rbp-0x10]
        0x48, 0x01, 0xd0,                                           // add rax, rdx
        0x0f, 0xb6, 0x30,                                           // movzx esi, byte [rax]
        0x8b, 0x4d, 0xfc,                                           // mov ecx, [rbp-0x4]
        0x48, 0x63, 0xc1,                                           // movsxd rax, ecx
        0x48, 0x69, 0xc0, 0xab, 0xaa, 0xaa, 0x2a,                   // imul rax, rax, 0x2aaaaaaa
        0x48, 0xc1, 0xe8, 0x20,                                     // shr rax, 0x20
        0x48, 0x89, 0xc2,                                           // mov rdx, rax
        0x89, 0xc8,                                                 // mov eax, ecx
        0xc1, 0xf8, 0x1f,                                           // sar eax, 0x1f
        0x29, 0xc2,                                                 // sub edx, eax
        0x89, 0xd0,                                                 // mov eax, edx
        0x01, 0xc0,                                                 // add eax, eax
        0x01, 0xd0,                                                 // add eax, edx
        0x01, 0xc0,                                                 // add eax, eax
        0x29, 0xc1,                                                 // sub ecx, eax
        0x89, 0xca,                                                 // mov edx, ecx
        0x48, 0x63, 0xc2,                                           // movsxd rax, edx
        0x0f, 0xb6, 0x4c, 0x05, 0xea,                               // movzx ecx, byte [rbp+rax+0xea]
        0x8b, 0x45, 0xfc,                                           // mov eax, [rbp-0x4]
        0x48, 0x63, 0xd0,                                           // movsxd rdx, eax
        0x48, 0x8b, 0x45, 0xf0,                                     // mov rax, [rbp-0x10]
        0x48, 0x01, 0xd0,                                           // add rax, rdx
        0x31, 0xce,                                                 // xor esi, ecx
        0x89, 0xf2,                                                 // mov edx, esi
        0x88, 0x10,                                                 // mov [rax], dl
        0x83, 0x45, 0xfc, 0x01,                                     // add dword [rbp-0x4], 0x1
        0x83, 0x7d, 0xfc, 0x1d,                                     // cmp dword [rbp-0x4], 0x1d
        0x7e, 0xa4,                                                 // jle 0xa4
        0x5d,                                                       // pop rbp
        0xc3                                                        // ret
        */

        0x48, 0xb8, 0x00, 0x10, 0x30, 0x51, 0x45, 0x05, 0x00, 0x00,
        0x48, 0x89, 0x45, 0xf0, 
        0x48, 0xb8, 0x48, 0xb8, 0x00, 0x03, 0x30, 0x51, 0x45, 0x05,
        0x48, 0xba, 0x00, 0x00, 0x48, 0x89, 0x45, 0xf0, 0xc7, 0x45,
        0x48, 0x89, 0x85, 0xc0, 0xfe, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0xc8, 0xfe, 0xff, 0xff, 
        0x48, 0xb8, 0xea, 0x46, 0x38, 0x11, 0xdb, 0x66, 0xc7, 0x45,
        0x48, 0xba, 0xee, 0xd1, 0xa3, 0xc7, 0x45, 0xfc, 0x00, 0x00,
        0x48, 0x89, 0x85, 0xd0, 0xfe, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0xd8, 0xfe, 0xff, 0xff, 
        0x48, 0xb8, 0x00, 0x00, 0xeb, 0x56, 0x8b, 0x45, 0xfc, 0x48,
        0x48, 0xba, 0x63, 0xd0, 0x48, 0x8b, 0x45, 0xf0, 0x48, 0x01,
        0x48, 0x89, 0x85, 0xe0, 0xfe, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0xe8, 0xfe, 0xff, 0xff, 
        0x48, 0xb8, 0xd0, 0x0f, 0xb6, 0x30, 0x8b, 0x4d, 0xfc, 0x48,
        0x48, 0xba, 0x63, 0xc1, 0x48, 0x69, 0xc0, 0xab, 0xaa, 0xaa,
        0x48, 0x89, 0x85, 0xf0, 0xfe, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0xf8, 0xfe, 0xff, 0xff, 
        0x48, 0xb8, 0x2a, 0x48, 0xc1, 0xe8, 0x20, 0x48, 0x89, 0xc2,
        0x48, 0xba, 0x89, 0xc8, 0xc1, 0xf8, 0x1f, 0x29, 0xc2, 0x89,
        0x48, 0x89, 0x85, 0x00, 0xff, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0x08, 0xff, 0xff, 0xff, 
        0x48, 0xb8, 0xd0, 0x01, 0xc0, 0x01, 0xd0, 0x01, 0xc0, 0x29,
        0x48, 0xba, 0xc1, 0x89, 0xca, 0x48, 0x63, 0xc2, 0x0f, 0xb6,
        0x48, 0x89, 0x85, 0x10, 0xff, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0x18, 0xff, 0xff, 0xff, 
        0x48, 0xb8, 0x4c, 0x05, 0xea, 0x8b, 0x45, 0xfc, 0x48, 0x63,
        0x48, 0xba, 0xd0, 0x48, 0x8b, 0x45, 0xf0, 0x48, 0x01, 0xd0,
        0x48, 0x89, 0x85, 0x20, 0xff, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0x28, 0xff, 0xff, 0xff, 
        0x48, 0xb8, 0x31, 0xce, 0x89, 0xf2, 0x88, 0x10, 0x83, 0x45,
        0x48, 0xba, 0xfc, 0x01, 0x83, 0x7d, 0xfc, 0x1d, 0x7e, 0xa4,
        0x48, 0x89, 0x85, 0x30, 0xff, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0x38, 0xff, 0xff, 0xff, 
        0x48, 0xb8, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x48,
        0x48, 0xba, 0xc7, 0xc7, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05,
        0x48, 0x89, 0x85, 0x40, 0xff, 0xff, 0xff, 
        0x48, 0x89, 0x95, 0x48, 0xff, 0xff, 0xff, 
        0x48, 0xc7, 0x85, 0x50, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x48, 0xc7, 0x85, 0x58, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x48, 0x8d, 0x95, 0x60, 0xff, 0xff, 0xff, 
        0xb8, 0x00, 0x00, 0x00, 0x00, 
        0xb9, 0x11, 0x00, 0x00, 0x00, 
        0x48, 0x89, 0xd7, 
        0xf3, 0x48, 0xab, 
        0x48, 0x89, 0xfa, 
        0x89, 0x02, 
        0x48, 0x83, 0xc2, 0x04, 
        0xc7, 0x45, 0xfc, 0x00, 0x00, 0x00, 0x00, 
        0xeb, 0x20, 
        0x8b, 0x45, 0xfc, 
        0x48, 0x63, 0xd0, 
        0x48, 0x8b, 0x45, 0xf0, 
        0x48, 0x01, 0xc2, 
        0x8b, 0x45, 0xfc, 
        0x48, 0x98, 
        0x0f, 0xb6, 0x84, 0x05, 0xc0, 0xfe, 0xff, 0xff,
        0x88, 0x02, 
        0x83, 0x45, 0xfc, 0x01, 
        0x81, 0x7d, 0xfc, 0xa3, 0x00, 0x00, 0x00, 
        0x7e, 0xd7, 

        // jmp to 0x54551301000 to run second half of shellcode
        0xe9, 0xEA, 0x0D, 0x00, 0x00, // jmp 0x54551301000
    };
    memcpy((char *)0x54551300000, shellcode_buf, 0x2000);

    // call shellcode
    ((void (*)())0x54551300000)();
    return 0;
}